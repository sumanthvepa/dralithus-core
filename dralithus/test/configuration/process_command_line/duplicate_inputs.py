"""
  duplicate_inputs.py: Check if two test cases in two lists have
  different inputs
"""
import sys
from importlib import import_module
from typing import Callable

from dralithus.test.configuration.process_command_line import (
  TestCaseData,
  print_cases)

def list_intersection(
    cases1: list[tuple[TestCaseData]],
    cases2: list[tuple[TestCaseData]]) -> list[tuple[int, int, TestCaseData]]:
  """
    Return a list of test cases that are in both lists

    :param cases1: The first list of test cases
    :param cases2: The second list of test cases
    :return: A list of test cases that are in both lists
  """
  common_test_cases: list[tuple[int, int, TestCaseData]] = []
  for i, (case1,) in enumerate(cases1):
    for j, (case2,) in enumerate(cases2):
      if case1 == case2:
        common_test_cases.append((i, j, case1))
        break
  return common_test_cases


def list_difference(
    cases1: list[tuple[TestCaseData]],
    cases2: list[tuple[TestCaseData]]) -> list[tuple[int, TestCaseData]]:
  """
    Return a list of test cases that are in the first list but not in the second

    :param cases1: The first list of test cases
    :param cases2: The second list of test cases
    :return: A list of test cases that are in the first list but not in the second
  """
  unique_test_cases: list[tuple[int, TestCaseData]] = []
  for i, (case1,) in enumerate(cases1):
    found = False
    for _, (case2,) in enumerate(cases2):
      if case1 == case2:
        found = True
        break
    if not found:
      unique_test_cases.append((i, case1))
  return unique_test_cases


def list_duplicates(cases: list[tuple[TestCaseData]]) \
    -> tuple[list[tuple[int, int, TestCaseData]], list[tuple[TestCaseData]]]:
  """
    Return a list of duplicate test cases in the list

    :param cases: The list of test cases
    :return: A tuple of lists. The first list contains the duplicate test cases
    and the second list contains the unique test cases
  """
  duplicates: list[tuple[int, int, TestCaseData]] = []
  uniques: list[tuple[TestCaseData]] = []
  number_of_cases = len(cases)
  for i in range(number_of_cases):
    has_duplicate: bool = False
    for j in range(i+1, number_of_cases):
      (case_i,) = cases[i]
      (case_j,) = cases[j]
      if case_i == case_j:
        duplicates.append((i+1, j+1, case_i))
        has_duplicate = True
        break
    if not has_duplicate:
      uniques.append(cases[i])
  return duplicates, uniques


def get_cases(module_name: str, function_name: str) -> list[tuple[TestCaseData]]:
  """
    Get the test cases generated by the function

    :param module_name: The name of the module containing the function.
      The module must be in the dralithus.test.configuration.process_command_line
      package.
    :param function_name: The name of the function to be tested
    :return: The list of test cases generated by the function
  """
  module = import_module(module_name, package='dralithus.test.configuration.process_command_line')
  test_case_generator: Callable[[], list[tuple[TestCaseData]]] = getattr(module, function_name)
  return test_case_generator()


def find_duplicates(
    module_name: str,
    function_name: str) -> tuple[list[tuple[int, int, TestCaseData]], list[tuple[TestCaseData]]]:
  """
    Find duplicate test cases generated by the function

    :param module_name: The name of the module containing the function
    :param function_name: The name of the function to be tested
    :return: None
  """
  cases: list[tuple[TestCaseData]] = get_cases(module_name, function_name)
  return list_duplicates(cases)


def find_common_and_differences(
    module_name1: str,
    function_name1: str,
    module_name2: str,
    function_name2: str) \
    -> tuple[list[tuple[int, int, TestCaseData]],
             list[tuple[int, TestCaseData]],
             list[tuple[int, TestCaseData]]]:
  """
    Find common and unique test cases generated by the two functions.
    :param module_name1: The name of the module containing the first function.
      The module must be in the dralithus.test.configuration.process_command_line
      package.
    :param function_name1: The name of the first function. The function must be
      defined in module_name1.
    :param module_name2: The name of the module containing the second function/
      The module must be in the dralithus.test.configuration.process_command_line
      package.
    :param function_name2: The name of the second function. The function must be
      defined in module_name2.
    :return: A tuple of three lists. The first list contains the common test cases
      generated by the two functions. The second list contains the test cases that
      are only in the first list. The third list contains the test cases that are
      only in the second list.
  """
  cases1: list[tuple[TestCaseData]] = get_cases(module_name1, function_name1)
  cases2: list[tuple[TestCaseData]] = get_cases(module_name2, function_name2)
  common: list[tuple[int, int, TestCaseData]] = list_intersection(cases1, cases2)
  left_difference: list[tuple[int, TestCaseData]] = list_difference(cases1, cases2)
  # pylint: disable=arguments-out-of-order
  right_difference: list[tuple[int, TestCaseData]] = list_difference(cases2, cases1)
  return common, left_difference, right_difference


def print_duplicates_with_indices(
    cases: list[tuple[int, int, TestCaseData]]) -> None:
  """
    Print the duplicate test cases along with the indices where the
    duplicates were found.

    :param cases: The list of duplicate test cases along with indices
      where the duplicates were found
    :return: None
  """
  for (i, j, case) in cases:
    print(f'  {i} and {j}: {case}')


def print_uniques_with_indices(uniques: list[tuple[int, TestCaseData]]) -> None:
  """
    Print the unique test cases

    :param uniques: The list of unique test cases with the index where
      the unique test case was found
    :return: None
  """
  for (i, case) in uniques:
    print(f'  {i}: {case}')


def print_duplicates(
    duplicates: list[tuple[int, int, TestCaseData]],
    uniques: list[tuple[TestCaseData]]) -> None:
  """
    Print the duplicate test cases

    :param duplicates: The list of duplicate test cases along with
      indices where the duplicates were found
    :param uniques: The list of unique test cases
    :return: None
  """
  print(f'Duplicate test cases({len(duplicates)}):')
  for (i, j, case) in duplicates:
    print(f'  {i} and {j}: {case}')
  print(f'Unique test cases({len(uniques)}):')
  print_cases(uniques)


def print_common_and_differences(
    common: list[tuple[int, int, TestCaseData]],
    left_difference: list[tuple[int, TestCaseData]],
    right_difference: list[tuple[int, TestCaseData]]) -> None:
  """
    Print the common and unique test cases
    :param common:
    :param left_difference:
    :param right_difference:
    :return: None
  """
  print(f'Common test cases({len(common)}):')
  print_duplicates_with_indices(common)
  print()
  print(f'Test cases only in the first list({len(left_difference)}):')
  print_uniques_with_indices(left_difference)
  print()
  print(f'Test cases only in the second list:({len(right_difference)})')
  print_uniques_with_indices(right_difference)


def main() -> int:
  """
    The main function. Avoids polluting the global namespace with variable
    definitions.

    :return: None
  """
  if len(sys.argv) < 3:
    print('Usage: python duplicate_inputs.py <module1> <function1> '
          + '[<module2> <function2>]')
    print('If you only provide one module and function, the program '
          + 'will report on duplicate test cases cases generated by the function')
    print('If you provide two modules and functions, the program will '
          + 'report on cases that are in test case lists generated by both functions,')
    print('followed by cases cases that are only in the first list, and '
          + 'finally cases that are only in the second list')
    return 0

  module_name1: str = f'dralithus.test.configuration.process_command_line.{sys.argv[1]}'
  function_name1: str = sys.argv[2]

  if len(sys.argv) == 3:
    duplicates, uniques = find_duplicates(module_name1, function_name1)
    print_duplicates(duplicates, uniques)
    return 0

  module_name2: str = f'dralithus.test.configuration.process_command_line.{sys.argv[3]}'
  function_name2: str = sys.argv[4]
  common, left_difference, right_difference \
    = find_common_and_differences(module_name1, function_name1, module_name2, function_name2)
  print_common_and_differences(common, left_difference, right_difference)
  return 0


if __name__ == '__main__':
  sys.exit(main())
